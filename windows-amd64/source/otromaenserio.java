/* autogenerated by Processing revision 1283 on 2023-12-19 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;
import java.util.ArrayDeque;
import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class otromaenserio extends PApplet {





SoundFile file;
AudioIn in;
FFT fft;

String songDir = "D:/MUSICA/LIBRERIAS/tracklists/anu27";
List<String> songs = new ArrayList<>();
int cols, rows;
int bands = 512;
float w;
float[] spectrum = new float[bands];
float[] sum = new float[bands];
float[] logBins = new float[bands];
float[] scaledBins = new float[bands];
float binWidth = 0;
ArrayDeque<float[]> data = new ArrayDeque<>();
ArrayDeque<float[]> cookedData = new ArrayDeque<>();
final int maxEle = 100;
int vScale = 21;
int volume = 99;
float stretch =3.2f;
int zStart = 6000;
//a lo mejor cambiando la base del logaritmo se consigue distinta dinamica, ahora mismo se "pasa a dB" con el neperiano


/*
  para valores de "smoothing" mayores que 0.5 hay mas "ruido", y puede venir bien para "tirar encima un trapo" y que tenga mas "sitios de apoyo".
 el trapo es una malla de vertices
 
 para valores menores que 0.4 (default), y cercanos a 0.1, se parece mas a un EQ, el "terreno es mas planito", hay menos "ruido"
 */
float smoothing = 0.4f;

float maxLogBin = 0;
float minLogBin = 9999;

float angle = 0;
float wiggle1 =0;
float wiggle2 =0;
float cameraX=4200;
float cameraY=0;
float cameraZ=0;

boolean presUP = false;
boolean presDOWN = false;
boolean presLEFT = false;
boolean presRIGHT = false;

 public void setup() {
  /* size commented out by preprocessor */;
  background(150);

  readSongDir();

  fft= new FFT(this, bands);
  
  //loadSongFile();
  setupAudioIn();
  setupDisplay();
}

 public void draw() {
  background(0);

  renderCamera();

  readFFT();

  //showMouse();
  showGridHelper();
  //drawEQ();

  //drawSpectrogram();
  drawTerrain(TRIANGLE_STRIP);
  //drawTerrain(QUAD_STRIP);
  //drawTerrain(LINES);
}

 public void renderCamera() {

  wiggle1 = 150*sin(angle+0.0001f*millis());
  wiggle2 = 200*sin(0.5f*angle+0.0001f*millis());
  angle-=0.01f;

  if (presUP) {
    cameraZ+=20;
  }
  if (presDOWN) {
    cameraZ-=20;
  }
  if (presLEFT) {
    cameraX-=20;
  }
  if (presRIGHT) {
    cameraX+=20;
  }

  float posX = cameraX + wiggle2+width/2.0f;
  float posY = 3*mouseY + wiggle1  -height/2.0f;
  float posZ = zStart- cameraZ +(height/2.0f) / tan(PI*30.0f / 180.0f);
  float lookX = mouseX*stretch+wiggle2;
  float lookY = height-200+mouseY;
  float lookZ = 100;
  
  if(presRIGHT){
    println("position: "+posX+", "+ posY+", "+ posZ);
  }
  
  
  camera(posX,posY,posZ,lookX,lookY,lookZ, 0, 1, 0);
  
}

 public void readFFT() {
  if (in.isPlaying()) {
    fft.analyze(spectrum);
    final float[] clone = spectrum.clone();
    final float[] cookedClone = new float[clone.length];
    
    for (int i = 0; i < clone.length; i++) {
      float amp = clone[i];
      sum[i] += (amp - sum[i]) * smoothing;

      float y =vScale*10* (float) Math.log(sum[i]/height);
      
      cookedClone[i] = y;
    }
    cookedData.addFirst(cookedClone);
    data.addFirst(clone);
  }
  if (cookedData.size() >= maxEle) {
    cookedData.removeLast();
  }
  if (cookedData.size() > maxEle) {
    cookedData.clear();
  }
   if (cookedData.size() >= maxEle) {
    cookedData.removeLast();
  }
  if (cookedData.size() > maxEle) {
    cookedData.clear();
  }
}

 public void drawEQ() {
  stroke(0);
  for (int i = 0; i < bands; i++) {

    float amp = spectrum[i];
    sum[i] += (amp - sum[i]) * smoothing;

    float y =max(-height, 10* (float) Math.log(sum[i]/height)*vScale);
    stroke(130, 255, 0);
    line(scaledBins[i] + w/2, height, scaledBins[i] + w/2, height - y );

    stroke(255, 255/(i+1), i);
    fill(0, 0, 0, 0);
    // jugando con "height-y" , "height + y", "height", "y", se consiguen efectos guapos

    rect(scaledBins[i], height, w, -y-height);
  }
}

 public void setupDisplay() {
  w = width / bands;
  //binWidth = file.sampleRate()/bands;
  binWidth = 86;
  for (int i=0; i<bands; i++) {
    float temp = (i+1)*binWidth;
    if (temp < 20000) {
      logBins[i]= (float) Math.log10(temp);

      if (maxLogBin < logBins[i]) {
        maxLogBin = logBins[i];
      }
      if (minLogBin > logBins[i]) {
        minLogBin = logBins[i];
      }
      //print(logBins[i]+"--");
    }
  }

  //println("\n");

  for (int i=0; i<bands; i++) {
    scaledBins[i]= round(map(logBins[i], minLogBin, maxLogBin, 0, width));
    //print(scaledBins[i]+"--");
  }

  //println();
  //println(scaledBins.length);
}

 public void mouseClicked() {
  if (!in.isPlaying()) {
    in.play();
  } else {
    in.stop();
  }
}

 public void showGridHelper() {
  push();
  fill(0, 255, 0);
  stroke(0, 255, 0);
  line(0, 0, 0, 0, 0, 2000);
  line(0, 0, 0, 0, height, 0);
  line(0, 0, 0, width, 0, 0);
  pop();
}

 public void showMouse() {
  beginShape();
  textSize(200);
  fill(255);
  text(mouseX, 0, height/3);
  text(mouseY, 0, 100+height/3);
  endShape();
}

 public void readSongDir() {
  File[] files = new File(songDir).listFiles();

  for (File file : files) {
    if (!file.isDirectory() && !file.getName().contains("flac")) {
      songs.add(file.getPath());
    }
  }
}

 public String randomSong() {
  String song = songs.get(parseInt(random(songs.size())));
  println(song);
  return song;
}

public void mouseWheel(MouseEvent event) {
  final int count = event.getCount();
  stretch -= 0.05f*count;

  if (stretch < 1) {
    stretch = 1;
  }
  println("stretch: "+stretch);
}

public void keyPressed(KeyEvent event) {
  //CAMERA CONTROLS
  if (event.getKeyCode() == 87) {
    presUP = true;
  }
  if (event.getKeyCode() == 83) {
    presDOWN = true;
  }
  if (event.getKeyCode() == 68) { 
    presRIGHT = true;
  }
  if (event.getKeyCode() == 65) {
    presLEFT = true;
  }
  if (event.getKeyCode() == 84) {
    vScale--;
    println("vScale: "+vScale);
  }
  if (event.getKeyCode() == 71) {
    vScale++;
    println("vScale: "+vScale);
  }
  if (event.getKeyCode() == '1') {
    file.stop();
    file.removeFromCache();
    changeSongFile();
  }
  if (event.getKeyCode() == 38 && smoothing<0.8f) {
    smoothing+= 0.030f;
    println("smoothing: "+smoothing);
  }
  if (event.getKeyCode() == 40 && smoothing>=0.05f) {
    smoothing-=0.030f;
    println("smoothing: "+smoothing);
  }
}

public void keyReleased(KeyEvent event) {
  if (event.getKeyCode() == 87) {
    presUP = false;
  }
  if (event.getKeyCode() == 83) {
    presDOWN = false;
  }
  if (event.getKeyCode() == 68) { 
    presRIGHT = false;
  }
  if (event.getKeyCode() == 65) {
    presLEFT = false;
  }
  
}

private void setVolume() {
  file.amp(volume / 100.0f);
}

private void changeSongFile() {
  loadSongFile();
  if (!file.isPlaying()) {
    file.play();
  }
}

private void loadSongFile() {
  try {
    file = new SoundFile(this, randomSong());
    if (file != null) {
      file.amp(volume / 100f);
      fft.input(file);
    }
  }
  catch(Exception e) {
    loadSongFile();
  }
}

private void setupAudioIn() {
  try {
    Sound.list();
    in = new AudioIn(this,0);
    if (in != null) {
      in.start();
      //in.amp(volume / 100f);
      fft.input(in);
    }
  }
  catch(Exception e) {
    setupAudioIn();
  }
}




 public void drawTerrain(int mode) {
  int z = 0;
  int timeFrame = 0;
  int zPlus = 50;
  for (float[] row : cookedData) {
    //eleNum++;
    beginShape(mode);
    push();
    for (int i = 0; i < row.length; i++) {
      final float red = 255-3*i;
      final float greem = 190-8*i;
      final float blue = 4*i;

      fill(red, greem, blue, /*255-0.1**/255);
      translate(0, 0, z);
      
      if(stretch*scaledBins[i]>=0){
        // cuando el factor 0*timeFrame (-y*(0*timeFrame)) es demasiado grande, se desplaza casi en vertical y queda bastante guapo
        vertex(stretch*scaledBins[i], -row[i]+0*timeFrame,z);
        vertex(stretch*scaledBins[i], -row[i]+8*timeFrame,z+zPlus);
      }
    }
    if(stretch*scaledBins[row.length-1]>=0){
      vertex(stretch*scaledBins[row.length-1],height,z+zPlus);
    }
     pop();
    endShape();
    timeFrame++;
    z += 1.5f*zPlus;
  }
}


 public void drawSpectrogram() {
  final float yStart = height * 0.99f;

  int z = 0;
  int eleNum = 0;
  for (float[] ele : data) {
    eleNum++;
    for (int i = 0; i < ele.length; i++) {
      final float red = 255-3*i;
      final float greem = 190-8*i;
      final float blue = 4*i;

      push();
      fill(red, greem, blue, 255-0.1f*z);
      translate(0, 0, (0.2f*eleNum+1)*z);

      float amp = ele[i];
      sum[i] += (amp - sum[i]) * smoothing;

      float y =max(-height, vScale*10* (float) Math.log(sum[i]/height));


      rect(stretch*scaledBins[i], yStart, w, -y-height);
      pop();
    }
    z += 5;
  }
}


  public void settings() { size(displayWidth, displayHeight, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "otromaenserio" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
